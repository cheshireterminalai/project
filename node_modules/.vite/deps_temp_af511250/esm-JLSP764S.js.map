{
  "version": 3,
  "sources": ["../../@strike-protocols/solana-wallet-adapter/node_modules/base-x/src/index.js", "../../@strike-protocols/solana-wallet-adapter/node_modules/bs58/index.js", "../../@strike-protocols/solana-wallet-adapter/src/strikewallet.ts"],
  "sourcesContent": ["'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = require('safe-buffer').Buffer\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (psz < source.length) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n", "var basex = require('base-x')\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n", "\nimport {\n    Blockhash, Connection, Message,\n    PublicKey,\n    SIGNATURE_LENGTH_IN_BYTES, Signer, Transaction,\n    TransactionInstruction,\n    TransactionSignature\n} from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport {v4 as uuidv4} from \"uuid\";\nimport { EventEmitter } from \"eventemitter3\";\n\n\ninterface Connected {\n    publicKey: PublicKey;\n}\n\ninterface SendTransaction {\n    identifier: string;\n    signature: TransactionSignature;\n}\n\ninterface SerializableSignaturePubkeyPair {\n    signature: string;\n    pubkey: string;\n}\n\ninterface SignTransaction {\n    identifier: string;\n    signatures: SerializableSignaturePubkeyPair[];\n    feePayer: string;\n    recentBlockhash: Blockhash;\n    message: string;\n}\n\ninterface StrikeWalletMessage {\n    type: 'connected' | 'sendTransaction' | 'signTransaction';\n    error?: string;\n    connected?: Connected;\n    sendTransaction?: SendTransaction;\n    signTransaction?: SignTransaction;\n}\n\ninterface TransactionError {\n    message: string\n}\n\ninterface PendingTransactions {\n    [hash: string]: SendTransaction | SignTransaction | null\n}\n\ninterface PendingTransactionErrors {\n    [hash: string]: TransactionError | null\n}\n\ninterface SerializableInstruction {\n    data: string,\n    accountMetas: {address: string, signer: boolean, writable: boolean}[],\n    programId: string\n}\n\nconst DEFAULT_SIGNATURE_BUFFER = Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0)\n\nexport interface SignerOptions {\n    signers?: Signer[];\n}\n\nexport class StrikeWallet extends EventEmitter {\n    isLoggedIn: boolean;\n    url = 'https://wallet.strikeprotocols.com';\n    private _pendingTransactions: PendingTransactions;\n    private _pendingTransactionErrors: PendingTransactionErrors;\n    private _timers: number[];\n    private _wallet: Window | null;\n    private _connecting: boolean;\n    private _publicKey: PublicKey | null;\n\n    constructor() {\n        super()\n        this.isLoggedIn = false\n        this._pendingTransactions = {}\n        this._pendingTransactionErrors = {}\n        this._timers = []\n        this._wallet = null;\n        this._connecting = false\n        this._publicKey = null\n\n        window.addEventListener(\"message\", (e) => {\n            this.handleWalletMessage(e.data as StrikeWalletMessage)\n        })\n    }\n\n    async connect(url: string | null): Promise<PublicKey> {\n        try {\n            this.url = url || this.url\n            const origin = encodeURIComponent(window.location.origin);\n            const connectUrl = `${this.url}/connect?origin=${origin}`;\n            this._connecting = true\n            this._wallet = window.open(connectUrl, `strike-wallet-${origin}`, \"height=900,width=800,menubar=no,status=no,toolbar=no\");\n            if (!this._wallet) {\n                this._connecting = false\n                throw new Error(\"Unable to connect to wallet\")\n            }\n            this._timers.push(window.setInterval(() => {\n                if (this._wallet!.closed) {\n                    this.cleanUp();\n                } else if (this._wallet) {\n                    this._wallet.postMessage({type: 'heartbeat'}, this.url)\n                }\n            }, 100));\n            return new Promise<PublicKey>((resolve, reject) => {\n                const timer = window.setInterval(() => {\n                    if (this.isLoggedIn && this._publicKey) {\n                        this.clearTimer(timer);\n                        resolve(this._publicKey!)\n                    } else if (!this.isLoggedIn && !this._connecting) {\n                        this.clearTimer(timer);\n                        reject(new Error(\"Unable to connect to Strike\"))\n                    }\n                }, 100);\n                this._timers.push(timer)\n            })\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public cleanUp = () => {\n        [...this._timers].forEach(t => this.clearTimer(t));\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.close()\n        }\n        this._wallet = null\n        this.emit('disconnected')\n    }\n\n    public async signTransaction(transaction: Transaction): Promise<Transaction> {\n        this.verifyCanSignRequests([transaction])\n        try {\n            return this.signOneTransaction(transaction);\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public async signAllTransactions(transactions: Transaction[]): Promise<Transaction[]> {\n        this.verifyCanSignRequests(transactions)\n        try {\n            return this.signMultipleTransactions(transactions);\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public async sendTransaction(\n        transaction: Transaction,\n        connection: Connection,\n        options?: SignerOptions,\n    ): Promise<TransactionSignature> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new Error(\"Not Connected\");\n\n            const transactionIdentifier = uuidv4()\n            this._pendingTransactions[transactionIdentifier] = null;\n            const signers = options ? options.signers : undefined;\n\n            if (signers && signers!.length > 0) {\n                return new Promise<TransactionSignature>((resolve, reject) => {\n                    this.signOneTransaction(transaction, transactionIdentifier).then(walletTransaction => {\n                        this._pendingTransactions[transactionIdentifier] = null\n                        signers?.length && walletTransaction.partialSign(...signers);\n                        wallet.postMessage({\n                            type: \"sendFinalTransaction\", sendFinalTransaction: {\n                                transactionIdentifier,\n                                signaturePubkeyPairs: walletTransaction.signatures.filter(sp => sp.signature != null).map(sp => {\n                                    return {\n                                        'pubkey': sp.publicKey.toBase58(),\n                                        'signature': sp.signature!.toString('base64')\n                                    }\n                                })\n                            }\n                        }, this.url);\n                        const timer = window.setInterval(() => {\n                            const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SendTransaction\n                            const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                            if (pendingTransaction != null || pendingTransactionError != null) {\n                                this.clearTimer(timer);\n                                pendingTransaction && resolve(pendingTransaction.signature)\n                                pendingTransactionError && reject(pendingTransactionError)\n                            }\n                        }, 100);\n                        this._timers.push(timer)\n                    }).catch((error) => {\n                        reject(error)\n                        throw error;\n                    })\n                })\n            } else {\n                const instructions = this.instructionsToSerializableInstructions(transaction.instructions)\n                return new Promise<TransactionSignature>((resolve, reject) => {\n                    wallet.postMessage({\n                        type: \"sendTransaction\",\n                        sendTransaction: { instructions, transactionIdentifier }\n                    }, this.url);\n                    const timer = window.setInterval(() => {\n                        const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SendTransaction\n                        const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                        if (pendingTransaction != null || pendingTransactionError != null) {\n                            this.clearTimer(timer);\n                            pendingTransaction && resolve(pendingTransaction.signature)\n                            pendingTransactionError && reject(pendingTransactionError)\n                        }\n                    }, 100);\n                    this._timers.push(timer)\n                })\n            }\n        } catch (error) {\n            throw error;\n        }\n    }\n\n\n    private clearTimer = (timer: number) => {\n        this._timers = this._timers.filter(t => t != timer)\n        window.clearInterval(timer);\n    }\n\n    private instructionsToSerializableInstructions = (instructions: TransactionInstruction[]): SerializableInstruction[] => instructions.map(i => {\n        return {\n            'programId': i.programId.toBase58(),\n            'accountMetas': i.keys.map(k => {\n                return {\n                    address: k.pubkey.toBase58(),\n                    signer: k.isSigner,\n                    writable: k.isWritable,\n                }\n            }),\n            'data': window.btoa(String.fromCharCode(...i.data)),\n        }\n    })\n\n    private buildTransaction(pendingTransaction: SignTransaction): Transaction {\n        let message = Message.from(Buffer.from(Uint8Array.from(window.atob(pendingTransaction.message!), c => c.charCodeAt(0))))\n        return Transaction.populate(\n            message,\n            Array.from({length: message.header.numRequiredSignatures}, (_v, i) => {\n                let sigPubkeyPair = pendingTransaction.signatures.find(s => s.pubkey == message.accountKeys[i].toBase58())\n                return bs58.encode(sigPubkeyPair\n                    ? Buffer.from(Uint8Array.from(window.atob(sigPubkeyPair.signature), c => c.charCodeAt(0)))\n                    : DEFAULT_SIGNATURE_BUFFER\n                )\n            })\n        )\n    }\n\n    private verifyCanSignRequests(transactions: Transaction[]) {\n        transactions.forEach(transaction => {\n            if (transaction.signatures.some(s => s.signature != null)) {\n                throw new Error(\"Strike does not support this signing mode\")\n            }\n        })\n    }\n\n    private signOneTransaction(transaction: Transaction, transactionIdentifier = uuidv4()): Promise<Transaction> {\n        const wallet = this._wallet;\n        if (!wallet) throw new Error(\"Not Connected\");\n\n        const instructions = this.instructionsToSerializableInstructions(transaction.instructions)\n        this._pendingTransactions[transactionIdentifier] = null;\n        return new Promise<Transaction>((resolve, reject) => {\n            wallet.postMessage({type: \"signTransaction\", signTransaction: { instructions, transactionIdentifier }}, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SignTransaction\n                const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                if (pendingTransaction != null || pendingTransactionError != null) {\n                    this.clearTimer(timer)\n                    pendingTransaction && resolve(this.buildTransaction(pendingTransaction))\n                    pendingTransactionError &&  reject(pendingTransactionError)\n                }\n            }, 100);\n            this._timers.push(timer)\n        });\n    }\n\n    private signMultipleTransactions(transactions: Transaction[]): Promise<Transaction[]> {\n        const wallet = this._wallet;\n        if (!wallet) throw new Error(\"Not Connected\");\n\n        const serializedTransactions = transactions.map((t) => {\n            return {\n                instructions: this.instructionsToSerializableInstructions(t.instructions),\n                transactionIdentifier: uuidv4()\n            }\n        })\n        const transactionIdentifiers = serializedTransactions.map((t) => t.transactionIdentifier)\n        transactionIdentifiers.forEach((transactionIdentifier) => this._pendingTransactions[transactionIdentifier] = null)\n        return new Promise<Transaction[]>((resolve, reject) => {\n            wallet.postMessage({type: \"signAllTransactions\", signAllTransactions: {transactions: serializedTransactions}}, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransactions = transactionIdentifiers.map((txId) => this._pendingTransactions[txId] as SignTransaction)\n                const pendingTransactionErrors = transactionIdentifiers.map((txId) => this._pendingTransactionErrors[txId])\n                if (pendingTransactions.every((t) => t != null)) {\n                    this.clearTimer(timer)\n                    resolve(pendingTransactions.map((pt) => this.buildTransaction(pt)))\n                } else if (pendingTransactionErrors.some((e) => e != null)) {\n                    this.clearTimer(timer)\n                    reject(pendingTransactionErrors.find((e) => e != null))\n                }\n            }, 100);\n            this._timers.push(timer)\n        });\n    }\n\n    private handleWalletMessage = (data: StrikeWalletMessage) => {\n        if (data.type == \"connected\") {\n            this._connecting = false;\n            if (!data.error) {\n                this.isLoggedIn = true;\n                if (data.connected?.publicKey) {\n                    this._publicKey = new PublicKey(data.connected.publicKey);\n                }\n            }\n        } else if ([\"sendTransaction\", \"sendFinalTransaction\"].includes(data.type)) {\n            const transactionIdentifier = data.sendTransaction?.identifier\n            if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                if (data.error) {\n                    this._pendingTransactionErrors[transactionIdentifier] = {message: data.error};\n                } else {\n                    this._pendingTransactions[transactionIdentifier] = data.sendTransaction || null\n                }\n            }\n        } else if (data.type == \"signTransaction\") {\n            const transactionIdentifier = data.signTransaction?.identifier\n            if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                if (data.error) {\n                    this._pendingTransactionErrors[transactionIdentifier] = {message: data.error}\n                } else {\n                    this._pendingTransactions[transactionIdentifier] = data.signTransaction || null\n                }\n            }\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["i", "j", "bs58"]
}
