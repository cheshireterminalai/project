import {
  require_eventemitter3
} from "./chunk-AD6JOGMB.js";
import {
  PublicKey,
  init_index_browser_esm
} from "./chunk-NUB6R5RU.js";
import {
  require_safe_buffer
} from "./chunk-7QQYEK5K.js";
import {
  __commonJS,
  __toESM
} from "./chunk-MVEJMUOB.js";

// node_modules/@project-serum/sol-wallet-adapter/node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/@project-serum/sol-wallet-adapter/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (psz < source.length) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0, 0, zeroes);
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module.exports = base;
  }
});

// node_modules/@project-serum/sol-wallet-adapter/node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/@project-serum/sol-wallet-adapter/node_modules/bs58/index.js"(exports, module) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// node_modules/@project-serum/sol-wallet-adapter/dist/esm/index.js
var import_eventemitter3 = __toESM(require_eventemitter3());
init_index_browser_esm();
var import_bs58 = __toESM(require_bs58());
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Wallet = class extends import_eventemitter3.default {
  constructor(provider, _network) {
    super();
    this._network = _network;
    this._publicKey = null;
    this._popup = null;
    this._handlerAdded = false;
    this._nextRequestId = 1;
    this._autoApprove = false;
    this._responsePromises = /* @__PURE__ */ new Map();
    this.handleMessage = (e) => {
      var _a;
      if (this._injectedProvider && e.source === window || e.origin === ((_a = this._providerUrl) === null || _a === void 0 ? void 0 : _a.origin) && e.source === this._popup) {
        if (e.data.method === "connected") {
          const newPublicKey = new PublicKey(e.data.params.publicKey);
          if (!this._publicKey || !this._publicKey.equals(newPublicKey)) {
            if (this._publicKey && !this._publicKey.equals(newPublicKey)) {
              this.handleDisconnect();
            }
            this._publicKey = newPublicKey;
            this._autoApprove = !!e.data.params.autoApprove;
            this.emit("connect", this._publicKey);
          }
        } else if (e.data.method === "disconnected") {
          this.handleDisconnect();
        } else if (e.data.result || e.data.error) {
          const promises = this._responsePromises.get(e.data.id);
          if (promises) {
            const [resolve, reject] = promises;
            if (e.data.result) {
              resolve(e.data.result);
            } else {
              reject(new Error(e.data.error));
            }
          }
        }
      }
    };
    this._beforeUnload = () => {
      void this.disconnect();
    };
    if (isInjectedProvider(provider)) {
      this._injectedProvider = provider;
    } else if (isString(provider)) {
      this._providerUrl = new URL(provider);
      this._providerUrl.hash = new URLSearchParams({
        origin: window.location.origin,
        network: this._network
      }).toString();
    } else {
      throw new Error("provider parameter must be an injected provider or a URL string.");
    }
  }
  handleConnect() {
    var _a;
    if (!this._handlerAdded) {
      this._handlerAdded = true;
      window.addEventListener("message", this.handleMessage);
      window.addEventListener("beforeunload", this._beforeUnload);
    }
    if (this._injectedProvider) {
      return new Promise((resolve) => {
        void this.sendRequest("connect", {});
        resolve();
      });
    } else {
      window.name = "parent";
      this._popup = window.open((_a = this._providerUrl) === null || _a === void 0 ? void 0 : _a.toString(), "_blank", "location,resizable,width=460,height=675");
      return new Promise((resolve) => {
        this.once("connect", resolve);
      });
    }
  }
  handleDisconnect() {
    if (this._handlerAdded) {
      this._handlerAdded = false;
      window.removeEventListener("message", this.handleMessage);
      window.removeEventListener("beforeunload", this._beforeUnload);
    }
    if (this._publicKey) {
      this._publicKey = null;
      this.emit("disconnect");
    }
    this._responsePromises.forEach(([, reject], id) => {
      this._responsePromises.delete(id);
      reject(new Error("Wallet disconnected"));
    });
  }
  sendRequest(method, params) {
    return __awaiter(this, void 0, void 0, function* () {
      if (method !== "connect" && !this.connected) {
        throw new Error("Wallet not connected");
      }
      const requestId = this._nextRequestId;
      ++this._nextRequestId;
      return new Promise((resolve, reject) => {
        var _a, _b, _c, _d;
        this._responsePromises.set(requestId, [resolve, reject]);
        if (this._injectedProvider) {
          this._injectedProvider.postMessage({
            jsonrpc: "2.0",
            id: requestId,
            method,
            params: Object.assign({ network: this._network }, params)
          });
        } else {
          (_a = this._popup) === null || _a === void 0 ? void 0 : _a.postMessage({
            jsonrpc: "2.0",
            id: requestId,
            method,
            params
          }, (_c = (_b = this._providerUrl) === null || _b === void 0 ? void 0 : _b.origin) !== null && _c !== void 0 ? _c : "");
          if (!this.autoApprove) {
            (_d = this._popup) === null || _d === void 0 ? void 0 : _d.focus();
          }
        }
      });
    });
  }
  get publicKey() {
    return this._publicKey;
  }
  get connected() {
    return this._publicKey !== null;
  }
  get autoApprove() {
    return this._autoApprove;
  }
  connect() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this._popup) {
        this._popup.close();
      }
      yield this.handleConnect();
    });
  }
  disconnect() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this._injectedProvider) {
        yield this.sendRequest("disconnect", {});
      }
      if (this._popup) {
        this._popup.close();
      }
      this.handleDisconnect();
    });
  }
  sign(data, display) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!(data instanceof Uint8Array)) {
        throw new Error("Data must be an instance of Uint8Array");
      }
      const response = yield this.sendRequest("sign", {
        data,
        display
      });
      const signature = import_bs58.default.decode(response.signature);
      const publicKey = new PublicKey(response.publicKey);
      return {
        signature,
        publicKey
      };
    });
  }
  signTransaction(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.sendRequest("signTransaction", {
        message: import_bs58.default.encode(transaction.serializeMessage())
      });
      const signature = import_bs58.default.decode(response.signature);
      const publicKey = new PublicKey(response.publicKey);
      transaction.addSignature(publicKey, signature);
      return transaction;
    });
  }
  signAllTransactions(transactions) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield this.sendRequest("signAllTransactions", {
        messages: transactions.map((tx) => import_bs58.default.encode(tx.serializeMessage()))
      });
      const signatures = response.signatures.map((s) => import_bs58.default.decode(s));
      const publicKey = new PublicKey(response.publicKey);
      transactions = transactions.map((tx, idx) => {
        tx.addSignature(publicKey, signatures[idx]);
        return tx;
      });
      return transactions;
    });
  }
  diffieHellman(publicKey) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!(publicKey instanceof Uint8Array)) {
        throw new Error("Data must be an instance of Uint8Array");
      }
      const response = yield this.sendRequest("diffieHellman", {
        publicKey
      });
      return response;
    });
  }
};
function isString(a) {
  return typeof a === "string";
}
function isInjectedProvider(a) {
  return isObject(a) && "postMessage" in a && typeof a.postMessage === "function";
}
function isObject(a) {
  return typeof a === "object" && a !== null;
}

export {
  Wallet
};
//# sourceMappingURL=chunk-ARXEXSE2.js.map
